快速、频繁地计算⼀个索引区间内的元素之和 -- 前缀和
原始数组不会被修 改的情况下，频繁查询某个区间的累加和 -- 前缀和

差分数组的主要适⽤场景是频繁对原始数组的 某个区间的元素进⾏增减 -- 差分数组

双指针,左右指针,快慢指针
1、合并两个有序链表
2、链表的分解
3、合并 k 个有序链表, 难点在于，如何快速得到 k 个节点中的最⼩节点，接到结 果链表上？ 这⾥我们就要⽤到 优先级队列（⼆叉堆） 这种数据结构，把链表节点放⼊⼀个最⼩堆，就可以每次获得 k 个 节点中的最⼩节点
4、寻找单链表的倒数第 k 个节点
5、寻找单链表的中点
6、判断单链表是否包含环并找出环起点
7、判断两个单链表是否相交并找出交点

子串,子序列问题,查找满足一定条件的连续区间的性质（长度等）的问题 -- 滑动窗口

在具体的算法问题中，常⽤到的是「搜索左侧边界」和「搜索右侧边界」这两种场景，很少有让你单独「搜 索⼀个元素」。因为算法题⼀般都让你求最值，⽐如让你求吃⾹蕉的「最⼩速度」，让你求轮船的「最低运载能⼒」，求最 值的过程，必然是搜索⼀个边界的过程， --- 二分搜索 左右边界

田忌赛马

反转链表 -- 可以试试递归解决

括弧匹配 --- 栈

next larger element", "last smaller element --- 单调栈 入栈时弹出所有小于或大于当前入栈元素的值

滑动窗口的最值 --- 单调队列 入队时弹出所有小于或大于当前入队元素的值

LRU 算法 --- 哈希链表 LinkedHashMap

LFU 算法 --- 为不同的频率记录一个 哈希链表 LinkedHashMap

二叉树 --- ⼆叉树解题的思维模式分两类： 1、是否可以通过遍历⼀遍⼆叉树得到答案？如果可以，⽤⼀个 traverse 函数配合外部变量来实现，这叫 「遍历」的思维模式。 2、是否可以定义⼀个递归函数，通过⼦问题（⼦树）的答案推导出原问题的答案？如果可以，写出这个递归 函数的定义，并充分利⽤这个函数的返回值，这叫「分解问题」的思维模式。 ⽆论使⽤哪种思维模式，你都需要思考： 如果单独抽出⼀个⼆叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不⽤ 你操⼼，递归函数会帮你在所有节点上执⾏相同的操作

二叉树构造 --- 前序与中序,中序与后序, 前序与后序(把前序的第二个当成左子树的根就行)

二叉树序列化 --- 前序遍历 null 节点返回#号, 反序列化的时候前序遍历构建, 用数组 shift 出节点值

1. 归并排序的特点 --- 我们在使⽤ merge 函数合并两个有序数组的时候，其实 是可以知道⼀个元素 nums[i] 后边有多少个元素⽐ nums[i] ⼩的。
   1.1 「计算右侧⼩于当前元素的个数」
   1.2 「区间和的个数」--- 对前缀和数组的归并排序过程中计算个数

1. 二叉搜索树
1. 第 k 小的元素,中序遍历
1. 增删查

子集,排列,组合,暴力解, 岛屿问题(访问过的就淹掉) --- 回溯 DFS

最短路径 --- BFS (如果起点和终点都给出来了,可以用双向 BFS)

零钱对换, 股票交易, 背包问题 --- 动态规划 (最优子结构(能够通过⼦问题的最值得到原问题的最值), 重叠子问题, 状态转移方程)
